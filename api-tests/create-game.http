### Create Game - Creates a new game and returns gameId
### Variables loaded from .env.api-test file (gitignored, safe for tokens)
### Pre-request script reads .env.api-test file before every request (no caching!)

< {%
    // Pre-request script: Read .env file and load variables before EVERY request
    // This runs fresh each time to avoid any caching issues
    const fs = require('fs');
    const path = require('path');
    
    // Find .env file in workspace root (up from api-tests/)
    // Try multiple methods to find workspace root since __dirname may not work in REST Client
    let workspaceRoot;
    try {
        // Method 1: Try using process.cwd() (current working directory)
        const cwd = process.cwd();
        if (fs.existsSync(path.join(cwd, '.env.api-test'))) {
            workspaceRoot = cwd;
        } else if (fs.existsSync(path.join(cwd, 'api-tests'))) {
            workspaceRoot = cwd;
        } else {
            // Method 2: Try going up from current file location
            const scriptDir = typeof __dirname !== 'undefined' ? __dirname : path.dirname(process.env.REST_CLIENT_FILE || '');
            workspaceRoot = path.resolve(scriptDir, '..');
        }
    } catch (e) {
        // Fallback: assume workspace root is one level up
        workspaceRoot = path.resolve('..');
    }
    
    const envPath = path.join(workspaceRoot, '.env.api-test');
    
    // Force fresh read - use realpath to ensure we get the actual file
    let envPathResolved;
    try {
        envPathResolved = fs.realpathSync(envPath);
    } catch (e) {
        envPathResolved = envPath;
    }
    
    if (fs.existsSync(envPathResolved)) {
        // Read file fresh - no caching, force stat to check mod time
        const stats = fs.statSync(envPathResolved);
        const envContent = fs.readFileSync(envPathResolved, 'utf8');
        const lines = envContent.split('\n');
        
        let tokenFound = false;
        let apiUrlFound = false;
        lines.forEach(line => {
            const trimmed = line.trim();
            // Skip comments and empty lines
            if (trimmed && !trimmed.startsWith('#')) {
                const match = trimmed.match(/^([A-Z_]+)=(.+)$/);
                if (match) {
                    const key = match[1];
                    const value = match[2].trim();
                    // Set as global variable for use in request - force fresh set
                    client.global.set(key, value);
                    if (key === 'ID_TOKEN') {
                        tokenFound = true;
                        // Log token info (first/last 20 chars for debugging, not full token)
                        const tokenPreview = value.length > 40 
                            ? value.substring(0, 20) + '...' + value.substring(value.length - 20)
                            : value.substring(0, 20) + '...';
                        client.log(`[PRE-REQUEST] Freshly loaded ID_TOKEN from .env (modified: ${stats.mtime}): ${tokenPreview} (length: ${value.length})`);
                    }
                    if (key === 'API_URL') {
                        apiUrlFound = true;
                    }
                }
            }
        });
        
        if (!tokenFound) {
            client.log('[PRE-REQUEST] WARNING: ID_TOKEN not found in .env file!');
        }
        if (!apiUrlFound) {
            client.log('[PRE-REQUEST] WARNING: API_URL not found in .env file!');
        }
    } else {
        client.log(`[PRE-REQUEST] ERROR: .env file not found at ${envPathResolved}`);
    }
%}

POST {{API_URL}}/games
Authorization: Bearer {{ID_TOKEN}}
Content-Type: application/json

{
  "playerName": "Test Player"
}

> {%
    // Extract gameId from response and store globally for chaining
    if (response.status === 200) {
        const responseBody = JSON.parse(response.body);
        const gameId = responseBody.gameId || responseBody.game?.gameId;
        if (gameId) {
            client.global.set("gameId", gameId);
            client.log("✓ Game created! GameId stored: " + gameId);
        }
    } else {
        client.log("✗ Error: " + response.status + " - " + response.body);
    }
%}
